@dialects { jsx, ts }

@precedence {
  typeargs,
  typeMember,
  typePrefix,
  intersectionPrefixed @left,
  intersection @left,
  unionPrefixed @left,
  union @left,
  typeExtends @right,
  else @right,
  member,
  readonly,
  newArgs,
  call,
  instantiate,
  taggedTemplate,
  prefix,
  postfix,
  typeof,
  exp @left,
  times @left,
  plus @left,
  shift @left,
  loop,
  rel @left,
  satisfies,
  equal @left,
  bitAnd @left,
  bitXor @left,
  bitOr @left,
  and @left,
  or @left,
  ternary @right,
  assign @right,
  comma @left,
  statement @cut,
  predicate
}

@top Script { Hashbang? statement* }

@top SingleExpression { expression }

statement[@isGroup=Statement] {
  declaration |
  ExpressionStatement { expression semi }
}

declaration {
  VariableDeclaration
}

variableDeclarationKeyword {
  kw<"let"> //| kw<"var"> | kw<"const"> | ckw<"await">? ckw<"using">
}

VariableDeclaration {
  variableDeclarationKeyword commaSep1<patternAssignTyped> semi
}

pattern { VariableDefinition | ArrayPattern | ObjectPattern }

ArrayPattern { "[" commaSep<("..."? patternAssign)?> ~destructure "]" }

ObjectPattern { "{" commaSep<PatternProperty> ~destructure "}" }

patternAssign {
  pattern ("=" expressionNoComma)?
}

patternAssignTyped {
  pattern Optional? ("=" expressionNoComma)?
}

expression[@isGroup=Expression] {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma ("," expressionNoComma)+
}

expressionNoComma {
  Number |
  String |
  TemplateString |
  VariableName |
  boolean |
  kw<"null"> |
  ArrayExpression |
  ObjectExpression { "{" commaSep<Property> ~destructure "}" } |
  ParenthesizedExpression |
  JSXElement
}

ParenthesizedExpression { "(" expression ")" }

ArrayExpression {
  "[" commaSep1<"..."? expressionNoComma | ""> ~destructure "]"
}

propName { PropertyDefinition | "[" expression "]" ~destructure | Number ~destructure | String ~destructure }

Property {
  propName ~destructure (":" expressionNoComma)? |
  "..." expressionNoComma
}

PatternProperty {
  "..." patternAssign |
  ((PropertyName | Number | String) ~destructure (":" pattern)? |
   ("[" expression "]" ~destructure ":" pattern)) ("=" expressionNoComma)?
}

FunctionExpression {
  async? kw<"function"> Star? VariableDefinition? functionSignature Block
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

@skip {} {
  TemplateString[isolate] {
    templateStart (templateEscape | templateContent | templateExpr)* templateEnd
  }

  String[isolate] {
    '"' (stringContentDouble | Escape)* ('"' | "\n") |
    "'" (stringContentSingle | Escape)* ("'" | "\n")
  }
}

templateExpr[@name=Interpolation,isolate] { InterpolationStart expression? InterpolationEnd }

@skip {} {
  JSXElement {
    JSXSelfClosingTag |
    (JSXOpenTag | JSXFragmentTag) (JSXText | JSXElement | JSXEscape)* JSXCloseTag
  }
}

JSXSelfClosingTag { JSXStartTag jsxElementName jsxAttribute* JSXSelfCloseEndTag }

JSXOpenTag { JSXStartTag jsxElementName jsxAttribute* JSXEndTag }

JSXFragmentTag { JSXStartTag JSXEndTag }

JSXCloseTag { JSXStartCloseTag jsxElementName? JSXEndTag }

jsxElementName {
  JSXIdentifier |
  JSXBuiltin { JSXLowerIdentifier } |
  JSXNamespacedName |
  JSXMemberExpression
}

JSXMemberExpression { (JSXMemberExpression | JSXIdentifier | JSXLowerIdentifier) "." (JSXIdentifier | JSXLowerIdentifier) }

JSXNamespacedName { (JSXIdentifier | JSXNamespacedName | JSXLowerIdentifier) ":" (JSXIdentifier | JSXLowerIdentifier) }

jsxAttribute {
  JSXSpreadAttribute { "{" "..." expression "}" } |
  JSXAttribute { (JSXIdentifier | JSXNamespacedName | JSXLowerIdentifier) ("=" jsxAttributeValue)? }
}

jsxAttributeValue {
  JSXAttributeValue |
  JSXEscape { "{" expression "}" } |
  JSXElement
}

JSXEscape { "{" "..."? expression "}" }

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

// Keywords

kw<term> { @specialize[@name={term}]<identifier, term> }

// Contextual keywords

ckw<term> { @extend[@name={term}]<identifier, term> }

tskw<term> { @extend[@name={term},@dialect=ts]<identifier, term> }

async { @extend[@name=async]<identifier, "async"> }

// Contextual keyword in property context

pkwMod<term> { @extend[@name={term}]<word, term> }

tsPkwMod<term> { @extend[@name={term},@dialect=ts]<word, term> }

semi { ";" | insertSemi }

boolean { @specialize[@name=BooleanLiteral]<identifier, "true" | "false"> }

Star { "*" }

VariableName { identifier ~arrow }

VariableDefinition { identifier ~arrow }

TypeDefinition { identifier }

TypeName { identifier ~arrow }

Label { identifier }

PropertyName { word ~propName }

PropertyDefinition { word ~propName }

PrivatePropertyName { privateIdentifier }

PrivatePropertyDefinition { privateIdentifier }

Optional { "?" }

questionOp[@name=LogicOp] { "?" }

unionOp[@name=LogicOp] { "|" }

plusMin { ArithOp<"+" | "-"> }

intersectionOp[@name=LogicOp] { "&" }

@skip {
  spaces |
  newline |
  LineComment
//  BlockComment
}

@context trackNewline from "./tokens.js"

@external tokens noSemicolon from "./tokens" { noSemi }

@external tokens noSemicolonType from "./tokens" { noSemiType }

@external tokens operatorToken from "./tokens" {
 incdec[@name=ArithOp],
 incdecPrefix[@name=ArithOp]
 questionDot[@name="?."]
}

@external tokens jsx from "./tokens" { JSXStartTag }

@local tokens {
  InterpolationStart[closedBy=InterpolationEnd] { "${" }
  templateEnd { "`" }
  templateEscape[@name=Escape] { Escape }
  @else templateContent
}

@local tokens {
  blockCommentEnd { "*/" }
  blockCommentNewline { "\n" }
  @else blockCommentContent
}

@tokens {
  spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
  newline[@export] { $[\r\n\u2028\u2029] }

  LineComment[isolate] { "//" ![\n]* }

  Hashbang { "#!" ![\n]* }

  divide[@name=ArithOp] { "/" }

  @precedence { "/*", LineComment, divide }

  @precedence { "/*", LineComment, RegExp }

  identifierChar { @asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  word { identifierChar (identifierChar | @digit)* }

  identifier { word }

  privateIdentifier { "#" word }

  @precedence { spaces, newline, identifier }

  @precedence { spaces, newline, JSXIdentifier, JSXLowerIdentifier }

  @precedence { spaces, newline, word }

  hex { @digit | $[a-fA-F] }

  Number {
    (@digit ("_" | @digit)* ("." ("_" | @digit)*)? | "." @digit ("_" | @digit)*)
      (("e" | "E") ("+" | "-")? ("_" | @digit)+)? |
    @digit ("_" | @digit)* "n" |
    "0x" (hex | "_")+ "n"? |
    "0b" $[01_]+ "n"? |
    "0o" $[0-7_]+ "n"?
  }

  @precedence { Number "." }

  Escape {
    "\\" ("x" hex hex | "u" ("{" hex+ "}" | hex hex hex hex) | ![xu])
  }

  stringContentSingle { ![\\\n']+ }

  stringContentDouble { ![\\\n"]+ }

  templateStart { "`" }

  InterpolationEnd[openedBy=InterpolationStart] { "}" }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  BitOp<expr> { expr }
  CompareOp<expr> { expr }
  UpdateOp<expr> { expr }

  @precedence { "*", ArithOp }

  RegExp[isolate] { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ ("/" $[dgimsuvy]*)? }

  LessThan[@name=CompareOp] { "<" }

  "="[@name=Equals]
  "..."[@name=Spread]
  "=>"[@name=Arrow]

  "(" ")" "[" "]" "{" "}" "<" ">"

  "." "," ";" ":" "@"

  JSXIdentifier { $[A-Z_$\u{a1}-\u{10ffff}] (identifierChar | @digit | "-")* }
  JSXLowerIdentifier[@name=JSXIdentifier] { $[a-z] (identifierChar | @digit | "-")* }

  JSXAttributeValue { '"' !["]* '"' | "'" ![']* "'" }

  JSXStartCloseTag { "</" }

  JSXEndTag { ">" }

  JSXSelfCloseEndTag { "/>" }

  JSXText { ![<{]+ }

  tsAngleOpen[@dialect=ts,@name="<"] { "<" }
}

@external tokens insertSemicolon from "./tokens" { insertSemi }

@external propSource jsHighlight from "./highlight"

@detectDelim
